wellid_config = {
  "Controls": {
    "DMSO": [
      "A21",
      "A22",
      "B21",
      "B22",
      "C21",
      "C22",
      "D21",
      "D22",
      "I21",
      "I22",
      "J21",
      "J22",
      "K21",
      "K22",
      "L21",
      "L22"
    ],
    "1.8uMPolyGR+1uMMS023": [
      "G21",
      "G22",
      "H21",
      "H22",
      "O21",
      "O22",
      "P21",
      "P22"
    ],
    "1.8uMPolyGR": [
      "E21",
      "E22",
      "F21",
      "F22",
      "M21",
      "M22",
      "N21",
      "N22"
    ]
  },
  "Compound1": {
    "1.8uMPolyGR": {
      "20uM": [
        "E1",
        "E2",
        "F1",
        "F2"
      ],
      "6.33uM": [
        "E3",
        "E4",
        "F3",
        "F4"
      ],
      "2.01uM": [
        "E5",
        "E6",
        "F5",
        "F6"
      ],
      "0.634uM": [
        "E7",
        "E8",
        "F7",
        "F8"
      ],
      "0.201uM": [
        "E9",
        "E10",
        "F9",
        "F10"
      ],
      "0.0635uM": [
        "E11",
        "E12",
        "F11",
        "F12"
      ],
      "0.0201uM": [
        "E13",
        "E14",
        "F13",
        "F14"
      ],
      "0.0064uM": [
        "E15",
        "E16",
        "F15",
        "F16"
      ],
      "0.002uM": [
        "E17",
        "E18",
        "F17",
        "F18"
      ],
      "0.0006uM": [
        "E19",
        "E20",
        "F19",
        "F20"
      ]
    },
    "0uM": {
      "20uM": [
        "A1",
        "A2",
        "B1",
        "B2"
      ],
      "6.33uM": [
        "A3",
        "A4",
        "B3",
        "B4"
      ],
      "2.01uM": [
        "A5",
        "A6",
        "B5",
        "B6"
      ],
      "0.634uM": [
        "A7",
        "A8",
        "B7",
        "B8"
      ],
      "0.201uM": [
        "A9",
        "A10",
        "B9",
        "B10"
      ],
      "0.0635uM": [
        "A11",
        "A12",
        "B11",
        "B12"
      ],
      "0.0201uM": [
        "A13",
        "A14",
        "B13",
        "B14"
      ],
      "0.0064uM": [
        "A15",
        "A16",
        "B15",
        "B16"
      ],
      "0.002uM": [
        "A17",
        "A18",
        "B17",
        "B18"
      ],
      "0.0006uM": [
        "A19",
        "A20",
        "B19",
        "B20"
      ]
    }
  },
  "Compound2": {
    "1.8uMPolyGR": {
      "20uM": [
        "G1",
        "G2",
        "H1",
        "H2"
      ],
      "6.33uM": [
        "G3",
        "G4",
        "H3",
        "H4"
      ],
      "2.01uM": [
        "G5",
        "G6",
        "H5",
        "H6"
      ],
      "0.634uM": [
        "G7",
        "G8",
        "H7",
        "H8"
      ],
      "0.201uM": [
        "G9",
        "G10",
        "H9",
        "H10"
      ],
      "0.0635uM": [
        "G11",
        "G12",
        "H11",
        "H12"
      ],
      "0.0201uM": [
        "G13",
        "G14",
        "H13",
        "H14"
      ],
      "0.0064uM": [
        "G15",
        "G16",
        "H15",
        "H16"
      ],
      "0.002uM": [
        "G17",
        "G18",
        "H17",
        "H18"
      ],
      "0.0006uM": [
        "G19",
        "G20",
        "H19",
        "H20"
      ]
    },
    "0uM": {
      "20uM": [
        "C1",
        "C2",
        "D1",
        "D2"
      ],
      "6.33uM": [
        "C3",
        "C4",
        "D3",
        "D4"
      ],
      "2.01uM": [
        "C5",
        "C6",
        "D5",
        "D6"
      ],
      "0.634uM": [
        "C7",
        "C8",
        "D7",
        "D8"
      ],
      "0.201uM": [
        "C9",
        "C10",
        "D9",
        "D10"
      ],
      "0.0635uM": [
        "C11",
        "C12",
        "D11",
        "D12"
      ],
      "0.0201uM": [
        "C13",
        "C14",
        "D13",
        "D14"
      ],
      "0.0064uM": [
        "C15",
        "C16",
        "D15",
        "D16"
      ],
      "0.002uM": [
        "C17",
        "C18",
        "D17",
        "D18"
      ],
      "0.0006uM": [
        "C19",
        "C20",
        "D19",
        "D20"
      ]
    }
  },
  "Compound3": {
    "1.8uMPolyGR": {
      "20uM": [
        "M1",
        "M2",
        "N1",
        "N2"
      ],
      "6.33uM": [
        "M3",
        "M4",
        "N3",
        "N4"
      ],
      "2.01uM": [
        "M5",
        "M6",
        "N5",
        "N6"
      ],
      "0.634uM": [
        "M7",
        "M8",
        "N7",
        "N8"
      ],
      "0.201uM": [
        "M9",
        "M10",
        "N9",
        "N10"
      ],
      "0.0635uM": [
        "M11",
        "M12",
        "N11",
        "N12"
      ],
      "0.0201uM": [
        "M13",
        "M14",
        "N13",
        "N14"
      ],
      "0.0064uM": [
        "M15",
        "M16",
        "N15",
        "N16"
      ],
      "0.002uM": [
        "M17",
        "M18",
        "N17",
        "N18"
      ],
      "0.0006uM": [
        "M19",
        "M20",
        "N19",
        "N20"
      ]
    },
    "0uM": {
      "20uM": [
        "I1",
        "I2",
        "J1",
        "J2"
      ],
      "6.33uM": [
        "I3",
        "I4",
        "J3",
        "J4"
      ],
      "2.01uM": [
        "I5",
        "I6",
        "J5",
        "J6"
      ],
      "0.634uM": [
        "I7",
        "I8",
        "J7",
        "J8"
      ],
      "0.201uM": [
        "I9",
        "I10",
        "J9",
        "J10"
      ],
      "0.0635uM": [
        "I11",
        "I12",
        "J11",
        "J12"
      ],
      "0.0201uM": [
        "I13",
        "I14",
        "J13",
        "J14"
      ],
      "0.0064uM": [
        "I15",
        "I16",
        "J15",
        "J16"
      ],
      "0.002uM": [
        "I17",
        "I18",
        "J17",
        "J18"
      ],
      "0.0006uM": [
        "I19",
        "I20",
        "J19",
        "J20"
      ]
    }
  },
  "Compound4": {
    "1.8uMPolyGR": {
      "20uM": [
        "O1",
        "O2",
        "P1",
        "P2"
      ],
      "6.33uM": [
        "O3",
        "O4",
        "P3",
        "P4"
      ],
      "2.01uM": [
        "O5",
        "O6",
        "P5",
        "P6"
      ],
      "0.634uM": [
        "O7",
        "O8",
        "P7",
        "P8"
      ],
      "0.201uM": [
        "O9",
        "O10",
        "P9",
        "P10"
      ],
      "0.0635uM": [
        "O11",
        "O12",
        "P11",
        "P12"
      ],
      "0.0201uM": [
        "O13",
        "O14",
        "P13",
        "P14"
      ],
      "0.0064uM": [
        "O15",
        "O16",
        "P15",
        "P16"
      ],
      "0.002uM": [
        "O17",
        "O18",
        "P17",
        "P18"
      ],
      "0.0006uM": [
        "O19",
        "O20",
        "P19",
        "P20"
      ]
    },
    "0uM": {
      "20uM": [
        "K1",
        "K2",
        "L1",
        "L2"
      ],
      "6.33uM": [
        "K3",
        "K4",
        "L3",
        "L4"
      ],
      "2.01uM": [
        "K5",
        "K6",
        "L5",
        "L6"
      ],
      "0.634uM": [
        "K7",
        "K8",
        "L7",
        "L8"
      ],
      "0.201uM": [
        "K9",
        "K10",
        "L9",
        "L10"
      ],
      "0.0635uM": [
        "K11",
        "K12",
        "L11",
        "L12"
      ],
      "0.0201uM": [
        "K13",
        "K14",
        "L13",
        "L14"
      ],
      "0.0064uM": [
        "K15",
        "K16",
        "L15",
        "L16"
      ],
      "0.002uM": [
        "K17",
        "K18",
        "L17",
        "L18"
      ],
      "0.0006uM": [
        "K19",
        "K20",
        "L19",
        "L20"
      ]
    }
  }
}

from javax.swing import JFrame, JPanel, JLabel, JButton, JList, JScrollPane, JFileChooser, JComboBox, JCheckBox, ButtonGroup, DefaultComboBoxModel, JTextField, JOptionPane, BoxLayout, JTable, AbstractCellEditor, DefaultListModel
from javax.swing.table import TableCellRenderer, TableCellEditor, DefaultTableModel
from java.awt import BorderLayout, FlowLayout, Component
from java.lang import Thread, InterruptedException, Object
from java.awt.event import ActionListener, WindowAdapter, WindowEvent
from java.io import File
from java.util import Vector, Date
from java.text import SimpleDateFormat
from ij import IJ, ImageStack, ImagePlus

import os
import json
import random

class ComboBoxCellEditor(AbstractCellEditor, TableCellEditor):
    def __init__(self, gui):
        self.gui = gui
        # print("Debugging ComboBoxCellEditor __init__")
        # print(type(self.gui))
        self.comboBox = JComboBox()

    def getTableCellEditorComponent(self, table, value, isSelected, row, column):
        # Set the dropdown options based on the row
        #options = self.gui.dropdownOptions[row] if row < len(self.gui.dropdownOptions) else []
        directory = table.getModel().getValueAt(row, 0)
        options = self.gui.directoryToOptions.get(directory, [])
        self.comboBox.setModel(DefaultComboBoxModel(options))
        self.comboBox.setSelectedItem(value)
        return self.comboBox

    def getCellEditorValue(self):
        # Return the current value selected in the combo box
        return self.comboBox.getSelectedItem()
    
class WindowCloseListener(WindowAdapter):
    def __init__(self, app):
        self.app = app

    def windowClosed(self, windowEvent):
        self.app.windowClosed = True

class MontageGUI(ActionListener):

    def __init__(self):

        self.directoryToOptions = {}
        
        self.frame = JFrame("Montage Settings")
        self.frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)
        self.frame.setSize(600, 850)
        self.frame.setLayout(BorderLayout())

        # Directory Manager components
        self.tableModel = DefaultTableModel()
        self.tableModel.addColumn("Directory")
        self.tableModel.addColumn("Read Step")
        self.table = JTable(self.tableModel)
        comboBoxEditor = ComboBoxCellEditor(self)
        self.table.getColumnModel().getColumn(1).setCellEditor(comboBoxEditor)


        scrollPane = JScrollPane(self.table)

        # Buttons for Directory Manager
        directoryPanel = JPanel(FlowLayout(FlowLayout.CENTER))
        addButton = JButton("Add")
        addButton.addActionListener(self)
        directoryPanel.add(addButton)

        removeButton = JButton("Remove")
        removeButton.addActionListener(self)
        directoryPanel.add(removeButton)

        # Panel to hold the list and buttons
        directoryListPanel = JPanel(BorderLayout())
        directoryListPanel.add(scrollPane, BorderLayout.CENTER)
        directoryListPanel.add(directoryPanel, BorderLayout.SOUTH)

        # Panel to hold the directory list and other settings
        combinedNorthPanel = JPanel()
        combinedNorthPanel.setLayout(BoxLayout(combinedNorthPanel, BoxLayout.Y_AXIS))
        combinedNorthPanel.add(directoryListPanel)

        self.data = {
            "Compounds": ["Compound 1", "Compound 2", "Compound 3", "Compound 4", "All compounds"],
            "Concentrations": ["20uM", "6.33uM", "2.01uM", "0.634uM", "0.201uM", "0.0635uM", "0.0201uM", "0.0064uM", "0.002uM", "0.0006uM"]
        }
        
        # Sort by options
        sortPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        self.compoundsCheckBox = JCheckBox("Compounds")
        self.concentrationsCheckBox = JCheckBox("Concentrations")
        self.checkBoxGroup = ButtonGroup()
        self.checkBoxGroup.add(self.compoundsCheckBox)
        self.checkBoxGroup.add(self.concentrationsCheckBox)
        self.compoundsCheckBox.addActionListener(self.updateDropdown)
        self.concentrationsCheckBox.addActionListener(self.updateDropdown)
        sortLabel = JLabel("Sort by: ")
        sortPanel.add(sortLabel)
        sortPanel.add(self.compoundsCheckBox)
        sortPanel.add(self.concentrationsCheckBox)
        combinedNorthPanel.add(sortPanel)

        # Dynamic Combo Panel
        dynamicComboPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        dynamicComboLabel = JLabel("Select group to montage: ")
        self.dynamicCombo = JComboBox([])
        self.dynamicCombo.setEnabled(False)
        dynamicComboPanel.add(dynamicComboLabel)
        dynamicComboPanel.add(self.dynamicCombo)
        combinedNorthPanel.add(dynamicComboPanel)

        # PolyGR Combo Panel
        polyGRComboPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        polyGRComboLabel = JLabel("Include/Exclude PolyGR: ")
        self.polyGRCombo = JComboBox(Vector(["Include", "Exclude"]))
        polyGRComboPanel.add(polyGRComboLabel)
        polyGRComboPanel.add(self.polyGRCombo)
        combinedNorthPanel.add(polyGRComboPanel)

        # Quadrants Combo Panel
        quadrantsComboPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        quadrantsComboLabel = JLabel("Quadrants: ")
        self.quadrantsCombo = JComboBox(Vector(["Top left", "Top Right", "Bottom Left", "Bottom Right", "Random Quadrant", "All Quadrants"]))
        quadrantsComboPanel.add(quadrantsComboLabel)
        quadrantsComboPanel.add(self.quadrantsCombo)
        combinedNorthPanel.add(quadrantsComboPanel)

        # Channel Combo Panel
        channelComboPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        channelComboLabel = JLabel("Channel to Montage: ")
        self.channelCombo = JComboBox(Vector(["Composite", "RFP", "GFP", "DAPI", "Bright Field"]))
        channelComboPanel.add(channelComboLabel)
        channelComboPanel.add(self.channelCombo)
        combinedNorthPanel.add(channelComboPanel)

        # Scale Panel
        scalePanel = JPanel(FlowLayout(FlowLayout.LEFT))
        scaleLabel = JLabel("Scale: ")
        self.scaleField = JTextField("1.0", 10)
        scalePanel.add(scaleLabel)
        scalePanel.add(self.scaleField)
        combinedNorthPanel.add(scalePanel)

        # Label Font Size Panel
        labelFontSizePanel = JPanel(FlowLayout(FlowLayout.LEFT))
        labelFontSizeLabel = JLabel("Label font size: ")
        self.labelFontSizeField = JTextField("12", 10)
        labelFontSizePanel.add(labelFontSizeLabel)
        labelFontSizePanel.add(self.labelFontSizeField)
        combinedNorthPanel.add(labelFontSizePanel)

        # Border Size Panel
        borderSizePanel = JPanel(FlowLayout(FlowLayout.LEFT))
        borderSizeLabel = JLabel("Border size (pixels): ")
        self.borderSizeField = JTextField("10", 10)
        borderSizePanel.add(borderSizeLabel)
        borderSizePanel.add(self.borderSizeField)
        combinedNorthPanel.add(borderSizePanel)

        # Function call to get current date-time string
        datetimestr = self.getDateTimeStr()

        # Output Directory Panel
        outputDirectoryPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        outputDirectoryLabel = JLabel("Output directory: ")
        self.outputDirectoryField = JTextField(20)
        outputDirectoryButton = JButton("Browse")
        outputDirectoryButton.addActionListener(self.selectOutputDirectory)
        outputDirectoryPanel.add(outputDirectoryLabel)
        outputDirectoryPanel.add(self.outputDirectoryField)
        outputDirectoryPanel.add(outputDirectoryButton)
        combinedNorthPanel.add(outputDirectoryPanel)

        # Output Suffix Panel
        outputSuffixPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        outputSuffixLabel = JLabel("Output suffix: ")
        self.outputSuffixField = JTextField("_Montaged_{}".format(datetimestr), 20)
        outputSuffixPanel.add(outputSuffixLabel)
        outputSuffixPanel.add(self.outputSuffixField)
        combinedNorthPanel.add(outputSuffixPanel)

        self.frame.add(combinedNorthPanel, BorderLayout.NORTH)

        # Create Montage button
        montageButtonPanel = JPanel(FlowLayout())
        self.montageButton = JButton("Create Montage")
        self.montageButton.addActionListener(self)
        montageButtonPanel.add(self.montageButton)

        self.frame.add(montageButtonPanel, BorderLayout.SOUTH)

        # Display the frame
        self.frame.setVisible(True)

        # Default to negative
        self.createMontageClicked = False

        self.windowClosed = False
        self.frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)
        self.frame.addWindowListener(WindowCloseListener(self))

    def actionPerformed(self, event):
        if self.table.isEditing():
            self.table.getCellEditor().stopCellEditing()

        command = event.getActionCommand()
        if command == "Create Montage":
            if self.validateSettings():
                self.showConfirmationDialog()
            return
        elif command == "Add":
            self.addDirectory()
        elif command == "Remove":
            self.removeDirectory()


    def validateSettings(self):
        try:
            # Validate Input Directories
            if self.tableModel.getRowCount() == 0:
                JOptionPane.showMessageDialog(self.frame, "No input directories have been added.", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

            for i in range(self.tableModel.getRowCount()):
                directory = self.tableModel.getValueAt(i, 0)  # Get directory from the first column
                fileObj = File(directory)
                if not fileObj.isDirectory():
                    JOptionPane.showMessageDialog(self.frame, "The directory '{}' is not valid.".format(directory), "Settings Error", JOptionPane.ERROR_MESSAGE)
                    return False
        
            # Validate Output Suffix
            output_suffix = self.outputSuffixField.getText()
            if not output_suffix:
                JOptionPane.showMessageDialog(self.frame, "Output suffix cannot be empty.", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

            # Validate Output Directory
            output_directory = self.outputDirectoryField.getText()
            if not output_directory:
                JOptionPane.showMessageDialog(self.frame, "Output directory cannot  be empty.", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False
            elif not os.path.isdir(output_directory):
                JOptionPane.showMessageDialog(self.frame, "Output directory is not a valid directory.", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False
        
            # Validate Sortby Selection
            if not self.compoundsCheckBox.isSelected() and not self.concentrationsCheckBox.isSelected():
                JOptionPane.showMessageDialog(self.frame, "Please select a 'Sort by:' option (Compounds or Concentrations).", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

            # Validate Scale
            scale = float(self.scaleField.getText())
            if scale < 0.1 or scale > 1.0:
                JOptionPane.showMessageDialog(self.frame, "Scale value must contain a value between 0.1 and 1.0", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

            # Validate Label Font Size
            label_font_size = int(self.labelFontSizeField.getText())
            if label_font_size < 0 or label_font_size > 200 or label_font_size is None or label_font_size == "":
                JOptionPane.showMessageDialog(self.frame, "Label font value must contain a value between 0 and 200", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

            # Validate Border Size
            border_size = int(self.borderSizeField.getText())
            if border_size < 0 or border_size > 200:
                JOptionPane.showMessageDialog(self.frame, "Border size value must contain a value between 0 and 200", "Settings Error", JOptionPane.ERROR_MESSAGE)
                return False

        except ValueError as e:
            JOptionPane.showMessageDialog(self.frame, str(e))
            return False

        return True

    def updateDropdown(self, event):
        if self.compoundsCheckBox.isSelected():
            self.dynamicCombo.setModel(DefaultComboBoxModel(Vector(self.data["Compounds"])))
            self.dynamicCombo.setEnabled(True)
        elif self.concentrationsCheckBox.isSelected():
            self.dynamicCombo.setModel(DefaultComboBoxModel(Vector(self.data["Concentrations"])))
            self.dynamicCombo.setEnabled(True)
        else:
            self.dynamicCombo.setModel(DefaultComboBoxModel([]))
            self.dynamicCombo.setEnabled(False)

    def updateDropdownForRow(self, rowIndex, options):
        # self.table.getColumnModel().getColumn(1).setCellEditor(comboBoxEditor)
        # Update the options in the directory-to-options mapping
        directory = self.tableModel.getValueAt(rowIndex, 0)
        self.directoryToOptions[directory] = options

        # Repaint the table to reflect the change
        self.table.repaint()

    def addDirectory(self):
        chooser = JFileChooser()
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)
        if hasattr(self, 'lastSelectedDirectory') and self.lastSelectedDirectory is not None:
            chooser.setCurrentDirectory(File(self.lastSelectedDirectory).getParentFile())
        returnValue = chooser.showOpenDialog(self.frame)

        if returnValue == JFileChooser.APPROVE_OPTION:
                directory = chooser.getSelectedFile().getAbsolutePath()
                read_steps = get_kinetic_read_list(directory)
                read_steps_str = [str(step) for step in read_steps]

                # Add dropdown options for this row to the list
                # self.dropdownOptions.append(read_steps_str)
                self.directoryToOptions[directory] = read_steps_str
                
                # Add the directory to the table with a default option
                self.tableModel.addRow([directory, read_steps_str[0] if read_steps_str else "No steps found"])

                # Update the dropdown for the new row
                rowIndex = self.tableModel.getRowCount() - 1  # Index of the new row
                self.updateDropdownForRow(rowIndex, read_steps_str)

                self.lastSelectedDirectory = directory

                # Update the dropdown for the new row
                rowIndex = self.tableModel.getRowCount() - 1  # Index of the new row
                self.updateDropdownForRow(rowIndex, read_steps_str)

    def removeDirectory(self):
        selectedRow = self.table.getSelectedRow()
        if selectedRow >= 0:
            directory = self.tableModel.getValueAt(selectedRow, 0)
            if directory in self.directoryToOptions:
                del self.directoryToOptions[directory]
            self.tableModel.removeRow(selectedRow)



    def getDirectoryList(self):
        return [(self.tableModel.getValueAt(i, 0), self.tableModel.getValueAt(i, 1)) for i in range(self.tableModel.getRowCount())]

    def processDirectories(self):
        directory_list = self.getDirectoryList()
        print("Selected directories:", directory_list)
        if len(directory_list) < 1:
            print("User has not selected any directories, exiting script...")
        self.closeWindow()
            
    def getDateTimeStr(self):
        dateFormat = SimpleDateFormat("ddMMMyyyy-HHmm")
        return dateFormat.format(Date())

    def selectOutputDirectory(self, event):
        chooser = JFileChooser()
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)
        returnValue = chooser.showOpenDialog(self.frame)
        if returnValue == JFileChooser.APPROVE_OPTION:
            directory = chooser.getSelectedFile()
            self.outputDirectoryField.setText(directory.getAbsolutePath())
        
    def showConfirmationDialog(self):
        settingsPanel = JPanel()
        settingsPanel.setLayout(BoxLayout(settingsPanel, BoxLayout.Y_AXIS))

        # Add components to settingsPanel for each setting
        # Input Directories
        if self.tableModel.getRowCount() > 0:
            inputDirs = "<html><b>Input Plate Directories:</b><br>" + "<br>".join([self.tableModel.getValueAt(i, 0) for i in range(self.tableModel.getRowCount())]) + "</html>"
            settingsPanel.add(JLabel(inputDirs))

        # Output Directory
        settingsPanel.add(JLabel("<html><b>Output directory:</b> " + self.getOutputDirectory() + "</html>"))

        # Output Suffix
        settingsPanel.add(JLabel("<html><b>Output suffix:</b> " + self.getOutputSuffix() + "</html>"))

        # Sort By
        sortBy = "Compounds" if self.getSelectedCompounds() else "Concentrations"
        settingsPanel.add(JLabel("<html><b>Sort by:</b> " + sortBy + "</html>"))

        # Dynamic Combo
        if self.getSelectedCompounds():
            settingsPanel.add(JLabel("<html><b>Compound selected:</b> " + self.getDynamicComboValue() + "</html>"))
        elif self.getSelectedConcentrations():
            settingsPanel.add(JLabel("<html><b>Concentration selected:</b> " + self.getDynamicComboValue() + "</html>"))

        # Other Settings
        settingsPanel.add(JLabel("<html><b>PolyGR:</b> " + self.getPolyGRComboValue() + "</html>"))
        settingsPanel.add(JLabel("<html><b>Quadrant:</b> " + self.getQuadrantsComboValue() + "</html>"))
        settingsPanel.add(JLabel("<html><b>Channel:</b> " + self.getChannelComboValue() + "</html>"))
        settingsPanel.add(JLabel("<html><b>Scale:</b> " + self.getScaleValue() + "</html>"))
        settingsPanel.add(JLabel("<html><b>Label font size:</b> " + self.getLabelFontSize() + "</html>"))
        settingsPanel.add(JLabel("<html><b>Border pixel size:</b> " + self.getBorderSize() + "</html>"))

        # Show confirmation dialog
        option = JOptionPane.showConfirmDialog(self.frame, settingsPanel, "Confirm Settings", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE)

        # OK button pressed
        if option == JOptionPane.OK_OPTION:
            self.createMontageClicked = True
            self.frame.dispose()
        # Cancel button pressed - keep the application window open for modifications

    def getScaleValue(self):
        return self.scaleField.getText()

    def getLabelFontSize(self):
        return self.labelFontSizeField.getText()

    def getBorderSize(self):
        return self.borderSizeField.getText()

    def getOutputDirectory(self):
        return self.outputDirectoryField.getText()

    def getOutputSuffix(self):
        return self.outputSuffixField.getText()

    def getSelectedCompounds(self):
        return self.compoundsCheckBox.isSelected()

    def getSelectedConcentrations(self):
        return self.concentrationsCheckBox.isSelected()

    def getDynamicComboValue(self):
        return self.dynamicCombo.getSelectedItem()

    def getPolyGRComboValue(self):
        return self.polyGRCombo.getSelectedItem()

    def getQuadrantsComboValue(self):
        return self.quadrantsCombo.getSelectedItem()

    def getChannelComboValue(self):
        return self.channelCombo.getSelectedItem()
    
    def getAllSettings(self):
            # Retrieve all settings and return them
            return {
                "input_directory_list": self.getDirectoryList(), # Returns a list of tuples.
                "output_directory": self.getOutputDirectory(),
                "output_suffix": self.getOutputSuffix(),
                "sortby_value": self.getDynamicComboValue(),
                "compounds_selected": self.getSelectedCompounds(),
                "concentration_selection": self.getSelectedConcentrations(),
                "polygr_selection": self.getPolyGRComboValue(),
                "quadrant_selection": self.getQuadrantsComboValue(),
                "channel_selection": self.getChannelComboValue(),
                "scale": self.getScaleValue(),
                "label_font_size": self.getLabelFontSize(),
                "border_size": self.getBorderSize()
            }

def get_montage_settings(printout=False):
    gui = MontageGUI()
    gui.frame.setVisible(True)

    # Wait for the user to click Create Montage or close the window
    while not gui.createMontageClicked and not gui.windowClosed:
        try:
            Thread.sleep(100)
        except InterruptedException:
            break

    if gui.createMontageClicked:
        settings = gui.getAllSettings()
        return settings
    elif gui.windowClosed:
        print("Window closed by the user.")
        return None  # or exit the script as needed
    
class errorlist():
    def __init__(self):
        self.errors = []
    def log(self, directory, reason):
        print("ERROR " + str(reason) + ": " + str(directory))
        self.errors.append((directory, reason))
    def get_all_errors(self):
        return self.errors

def get_kinetic_read_list(directory):
    tif_files = find_tif_files_surfacedir(directory)
    if tif_files is None:
        print("ERROR get_kinetic_read_list: Could not find any .tif files")
        exit()
    unique_read_steps = []
    try:
        for file in tif_files:
            basename = os.path.basename(file)
            filename, ext = os.path.splitext(basename)
            filename_elements = filename.split("_")
            read_step = int(filename_elements[5]) # assumes read step number is 6th element in the underscore-delimited name
            if read_step not in unique_read_steps:
                unique_read_steps.append(read_step)
        unique_read_steps.sort()
    except Exception as e:
        unique_read_steps = ["Invalid: no read steps"]

    return unique_read_steps

def load_dict(wellID_config_fp):
    with open(wellID_config_fp, "r") as readfile:
        wellid_config = json.load(readfile)
        print("Successfully loaded wellID config from {}".format(wellID_config_fp))

def find_tif_files_surfacedir(directory):
    tif_files = []
    for item in os.listdir(directory):
        # Construct full file path
        full_path = os.path.join(directory, item)
        # Check if it's a file and has .tif extension
        if item.endswith('.tif'):
            #print(f"Adding {full_path} to list!")
            tif_files.append(full_path)
    if len(tif_files) < 1:
        tif_files = ["Invalid: no TIFs found"]
    return tif_files

def extract_well_id(filename):
    # Split the filename using underscore as a delimiter (this naming convention should not change from the Gen5 output)
    parts = filename.split('_')
    # Well ID is identified as a len >= 2 string where the first character is a number and subsequent characters are digits
    for part in parts:
        if len(part) >= 2 and part[0].isalpha() and part[1:].isdigit():
            return part
    # If well_id is not found, return None to be processed as an error
    return None

def isolate_wellIDs(settings, wellid_config):
    eligible_wellids = {}

    if settings["concentration_selection"] is False and settings["compounds_selected"] is True:
        compound = settings["sortby_value"]
        compound = compound.replace(" ", "")

        if settings["polygr_selection"] == "Include":
            gr_key = "1.8uMPolyGR"
        elif settings["polygr_selection"] == "Exclude":
            gr_key = "0uM"
        else:
            print("ERROR isolate_wellIDs: Settings returned polygr_selection as neither Include or Exclude")
            return None

        # Ensuring that the keys and their nested structure exist
        if compound not in eligible_wellids:
            eligible_wellids[compound] = {}
        if gr_key not in eligible_wellids[compound]:
            eligible_wellids[compound][gr_key] = {}

        for sortby, value in wellid_config[compound][gr_key].items():
            eligible_wellids[compound][gr_key][sortby] = value

    elif settings["concentration_selection"] is True and settings["compounds_selected"] is False:
        if settings["polygr_selection"] == "Include":
            gr_key = "1.8uMPolyGR"
        elif settings["polygr_selection"] == "Exclude":
            gr_key = "0uM"

        sortby = settings["sortby_value"]

        for compound, value in wellid_config.items():
            if "Compound" in compound:
                # Extract the desired value
                eligible_value = value.get(gr_key, {}).get(sortby)
                if eligible_value is not None:
                    # Store the value in a nested structure
                    if compound not in eligible_wellids:
                        eligible_wellids[compound] = {}
                    if gr_key not in eligible_wellids[compound]:
                        eligible_wellids[compound][gr_key] = {}
                    
                    eligible_wellids[compound][gr_key][sortby] = eligible_value
    
    return eligible_wellids

def isolate_quadrants(settings, isolated_wellids):
    quadrant = settings["quadrant_selection"]
    selected_wellIDs = {}

    for compound, gr_dict in isolated_wellids.items():
        for gr_key, sortby_dict in gr_dict.items():
            if compound not in selected_wellIDs:
                selected_wellIDs[compound] = {}
            if gr_key not in selected_wellIDs[compound]:
                selected_wellIDs[compound][gr_key] = {}

            for sortby, well_list in sortby_dict.items():
                if quadrant.lower() == "all quadrants":
                    selected_wellIDs[compound][gr_key][sortby] = well_list
                elif quadrant.lower() == "top left":
                    selected_wellIDs[compound][gr_key][sortby] = [well_list[0]]
                elif quadrant.lower() == "top right":
                    selected_wellIDs[compound][gr_key][sortby] = [well_list[1]]
                elif quadrant.lower() == "bottom left":
                    selected_wellIDs[compound][gr_key][sortby] = [well_list[2]]
                elif quadrant.lower() == "bottom right":
                    selected_wellIDs[compound][gr_key][sortby] = [well_list[3]]
                elif quadrant.lower() == "random":
                    random_number = random.randint(0, 3)
                    selected_wellIDs[compound][gr_key][sortby] = [well_list[random_number]]
                else:
                    print("ERROR get_specified_wellID: quadrant value was not recognized: {}".format(quadrant))
                    return None

    return selected_wellIDs

def filter_eligible_tifs(settings, directory, kinetic_readstep):
    """
    Function is meant to be used in a loop - once per directory (easier data management)
    Filters the .tif files once using the kinetic read step and the channel selection
    Assumes read step number is 6th element in the underscore-delimited name: basename_elements[5]
    Assumes channel ID is 5th element in the underscore-delimited name: basename_elements[4]
    """
    kinetic_readstep = int(kinetic_readstep)
    filtered_filelist = []
    channel_id = settings["channel_selection"]
    file_list = find_tif_files_surfacedir(directory)

    try:
        for file in file_list:
            basename = os.path.basename(file)
            filename, ext = os.path.splitext(basename)
            basename_elements = filename.split("_")
            basename_readstep = int(basename_elements[5])
            if basename_readstep == kinetic_readstep: # Check that the sixth element (which should be the readstep) matches the selected readstep
                if "composite" in channel_id.lower():
                    if channel_id.lower() in filename.lower():
                        filtered_filelist.append(file)
                else:
                    if channel_id.lower() in basename_elements[4].lower(): # Check that the fifth element (which should be the name) matches the selected channel ID
                        filtered_filelist.append(file)
        
        if len(filtered_filelist) < 1:
             return "ERROR filter_eligible_tifs: module could either not find kinetic_readstep ({}) or channel_id ({}) for the files in the directory: {}".format(kinetic_readstep, channel_id, directory)

        return filtered_filelist
    except Exception as e:
        return "ERROR filter_eligible_tifs: {}".format(e)

def match_tifs_to_wellIDs(eligible_tifs, eligible_wellIDs):

    if "Controls" in eligible_wellIDs.keys():
        for file in eligible_tifs:
            basename = os.path.basename(file)
            filename, ext = os.path.splitext(basename)
            extracted_wellid = extract_well_id(filename)

            for control_group, wells in eligible_wellIDs['Controls'].items():
                eligible_wellIDs['Controls'][control_group] = [file if well_id == extracted_wellid else well_id for well_id in wells]
    else:
        for file in eligible_tifs:
            basename = os.path.basename(file)
            filename, ext = os.path.splitext(basename)
            extracted_wellid = extract_well_id(filename)
            for compound, dosages in eligible_wellIDs.items():
                for dosage, wells in dosages.items():
                    for concentration, well_ids in wells.items():
                        wells[concentration] = [file if well_id == extracted_wellid else well_id for well_id in well_ids]

    return eligible_wellIDs

def filter_and_match_control_wellids(settings, wellid_config, eligible_tifs):
    """
    Picks a random wellID from the available wellIDs in the configuration
    The get_associated_quadrant_wellids function finds the associated wellIDs in that quadrant
    The final wellID is chosen from the associated wellIDs list depending on the quadrant selection in the settings
    """
    # Choose a random well for each of the controls
    control_wellid_config = {"Controls": {}}
    for control in wellid_config["Controls"]:
        elements = wellid_config["Controls"][control]
        selected_element = random.choice(elements)
        control_wellid_config["Controls"][control] = [selected_element]

    # print("Randomly chosen controls:")
    # print(control_wellid_config)

    # Replace the random well with its associated wellIDs from a 2x2 quadrant block
    for key in control_wellid_config['Controls']:
        control_wellid_config['Controls'][key] = [item for well_id in control_wellid_config['Controls'][key] for item in get_associated_quadrant_wellids(well_id)]
    
    # print("With Associated WellIDs:")
    # print(control_wellid_config)

    # Choose the specifici well from the 2x2 quadrant block based on the user quadrant_selection
    quadrant = settings["quadrant_selection"]
    for key in control_wellid_config['Controls']:
        if quadrant.lower() == "all":
            control_wellid_config['Controls'][key] = control_wellid_config['Controls'][key]
        elif quadrant.lower() == "top left":
            control_wellid_config['Controls'][key] = [control_wellid_config['Controls'][key][0]]
        elif quadrant.lower() == "top right":
            control_wellid_config['Controls'][key] = [control_wellid_config['Controls'][key][1]]
        elif quadrant.lower() == "bottom left":
            control_wellid_config['Controls'][key] = [control_wellid_config['Controls'][key][2]]
        elif quadrant.lower() == "bottom right":
            control_wellid_config['Controls'][key] = [control_wellid_config['Controls'][key][3]]
        elif quadrant.lower() == "random":
            random_number = random.randint(0, 3)
            control_wellid_config['Controls'][key] = [control_wellid_config['Controls'][key][random_number]]

    # print("After Quadrant Selection:")
    # print(control_wellid_config)

    matched_control_dict = match_tifs_to_wellIDs(eligible_tifs, control_wellid_config)

    # print("After filename matching:")
    # print(control_wellid_config)

    return matched_control_dict

def validate_files_to_montage(filepath_dict):
    def check_filepaths_in_dict(d):
        for key, value in d.items():
            if isinstance(value, list):
                if not all(os.path.isfile(filepath) for filepath in value):
                    return False
            elif isinstance(value, dict):
                if not check_filepaths_in_dict(value):
                    return False
        return True

    return check_filepaths_in_dict(filepath_dict)

def get_384_quadrant_wellID(quadrant):
    # Dictionary 
    quadrant_transform = {
        "Top Left": (0, 0),
        "Top Right": (0, 1),
        "Bottom Left": (1, 0),
        "Bottom Right": (1, 1)
    }

    well_ids = []
    for row in range(1, 17, 2):  # Skip every other row to match the 96-well layout
        for col in range(1, 25, 2):  # Skip every other column
            if quadrant != "Random":
                # Calculate row and column for the specific quadrant
                delta_row, delta_col = quadrant_transform[quadrant]
                well_id = "{}{}".format(chr(64 + row + delta_row), col + delta_col)
                well_ids.append(well_id)
            else:
                # Select a random well from the 2x2 block
                delta_row, delta_col = random.choice(list(quadrant_transform.values()))
                well_id = "{}{}".format(chr(64 + row + delta_row), col + delta_col)
                well_ids.append(well_id)

    return well_ids

def get_associated_quadrant_wellids(well_id):
    """
    Returns a list of wellIDs from the quadrant of the input wellID in a 384w plate
    """
    rows = "ABCDEFGHIJKLMNOP"
    row = well_id[0].upper()
    col = int(well_id[1:])

    # Adjust row and column to top-left of the quadrant
    row_index = rows.index(row)
    if row_index % 2 != 0:
        top_row = rows[row_index - 1]
        bottom_row = row
    else:
        top_row = row
        bottom_row = rows[row_index + 1]

    left_col = col - 1 if col % 2 == 0 else col

    # Generate the well IDs of the quadrant
    quadrant_wells = [
        "{}{}".format(top_row, left_col),
        "{}{}".format(top_row, left_col + 1),
        "{}{}".format(bottom_row, left_col),
        "{}{}".format(bottom_row, left_col + 1)
    ]

    return quadrant_wells

# def create_stack_old(filelist):
#     stack = None
#     for filepath in filelist:
#         img = IJ.openImage(filepath)
#         if stack is None:
#             # Initialize the stack with the first image
#             stack = ImageStack(img.getWidth(), img.getHeight())
#         stack.addSlice(img.getProcessor())
#         print("Added slice {} to stack".format(filepath))
#     print("Stack Generated")
#     # Create an ImagePlus object with the stack and show it
#     stackedImage = ImagePlus("Stacked Image", stack)
    
#     #stackedImage.show()
#     return stackedImage

def create_stack(filelist):
    stack = None
    for filepath, label_name in filelist:
        img = IJ.openImage(filepath)
        if stack is None:
            # Initialize the stack with the first image
            stack = ImageStack(img.getWidth(), img.getHeight())
        stack.addSlice(img.getProcessor())
        print("Added slice {} to stack".format(filepath))
    print("Stack Generated")
    # Create an ImagePlus object with the stack
    stackedImage = ImagePlus("Stacked Image", stack)
    print(filelist)
    for i, element in enumerate(filelist, start=1):
        filepath, label_name = element
        stackedImage.getStack().setSliceLabel(label_name, i)
    #stackedImage.show()
    return stackedImage

def create_stack_from_montage(image_list):
    stack = None
    for img in image_list:
        if stack is None:
            # Initialize the stack with the first image
            stack = ImageStack(img.getWidth(), img.getHeight())
        stack.addSlice(img.getProcessor())
        #print("Added slice")
    #print("Stack Generated")
    
    # Create an ImagePlus object with the stack
    stackedImage = ImagePlus("Stacked Image", stack)
    # for i, filename in enumerate(image_list, start=1):
    #     stackedImage.getStack().setSliceLabel(os.path.basename(filename), i)
    #     print("Kachow: ")
    #     print(os.path.basename(filename))
    return stackedImage

def create_single_montage(columns, rows, font_size, scale, border_size, stack):
    command = "columns={} rows={} scale={} font={} border={} label".format(columns, rows, scale, font_size, border_size)
    montage = IJ.run(stack, "Make Montage...", command)
    montage = IJ.getImage()

    # Check if montage is created successfully
    if montage is None:
        print("Montage creation failed.")
        return None

    return montage

def create_final_montage(settings, directory, final_filedict):
    """
    final_filedict should have the same dictionary structure as the wellID config, but with wellIDs replaced with filepaths
    settings should be the same settings dict coming from MontageGUI
    all the filedicts coming in should have been validated in prior processes, this function will not validate anything.
    """
    # Output filepath will be the specified output directory, the source folder basename with the suffix + .tif
    output_filepath = os.path.join(settings["output_directory"], os.path.basename(directory) + settings["output_suffix"] + ".tif")
    
    dmso_filelist = []
    for filepath in final_filedict["Controls"]["DMSO"]:
        label_name = extract_well_id(os.path.basename(filepath)) + "_Control_DMSO"
        dmso_filelist.append((filepath, label_name))
    if len(dmso_filelist) > 1:
        dmso_stack = create_stack(dmso_filelist)
        dmso_montage = create_single_montage(2, 2, settings["label_font_size"], settings["scale"], settings["border_size"], dmso_stack)
    else:
        dmso_montage = dmso_filelist[0]

    ms023_filelist = []
    for filepath in final_filedict["Controls"]["1.8uMPolyGR+1uMMS023"]:
        label_name = extract_well_id(os.path.basename(filepath)) + "_Control_1.8uMGR+1uMMS023"
        ms023_filelist.append((filepath, label_name))
    if len(ms023_filelist) > 1:
        ms023_stack = create_stack(ms023_filelist)
        ms023_montage = create_single_montage(2, 2, settings["label_font_size"], settings["scale"], settings["border_size"], ms023_stack)
    else:
        ms023_montage = ms023_filelist[0]

    gr_filelist = []
    for filepath in final_filedict["Controls"]["1.8uMPolyGR"]:
        label_name = extract_well_id(os.path.basename(filepath)) + "_Control_1.8uMPolyGR"
        gr_filelist.append((filepath, label_name))
    if len(ms023_filelist) > 1:
        gr_stack = create_stack(gr_filelist)
        gr_montage = create_single_montage(2, 2, settings["label_font_size"], settings["scale"], settings["border_size"], gr_stack)
    else:
        # If the length of the filelist is not more than one, that indicates that it does not need to be a stack, and we can pass on the filepath and label
        # The lengths of the filelist would only be more than one (four) if the all quadrants was selected
        gr_montage = gr_filelist[0]

    # Exit case in case of an error here
    if dmso_montage is None or ms023_montage is None or gr_montage is None:
        errors.log(directory, "dmso_montage: {}, ms023_montage: {}, or gr_montage: {} returned as None".format(dmso_montage, ms023_montage, gr_montage))
        exit()

    final_montage_montages = [dmso_montage, ms023_montage, gr_montage]

    # 1. For All quadrants, first convert 2x 4x images to 2x 2x2 stacks.
    # 2. Convert individual stacks to montages. 
    # 3. Convert the two montages into stacks
    # 4. Convert stacks into montages 
    
    # Generate the array of filepaths specifically in that order to be loaded as a stack and then montaged
    if settings["quadrant_selection"].lower() == "all quadrants":
        # If all of the quadrants are selected, then montage the 2x2 block first as separate elements, and then create the montage
        # Deal with the controls first. Order should be DMSO, GR+, and GR+MS023 (left to right)
        # Create a stack for each control quadrant and append it to the array

        # Montage each of these stacks separately 
        for compound in final_filedict:
            if compound != "Controls":
                for gr_addition in final_filedict[compound]:
                    for concentration in final_filedict[compound][gr_addition]:
                        images_to_montage = []
                        for image_fp in final_filedict[compound][gr_addition][concentration]:
                            label_name = extract_well_id(os.path.basename(image_fp)) + "_" + compound + "_" + gr_addition + "_" + concentration
                            images_to_montage.append((image_fp, label_name))
                        stack = create_stack(images_to_montage)
                        montage = create_single_montage(2, 2, settings["label_font_size"], settings["scale"], settings["border_size"], stack)
                        final_montage_montages.append(montage)
        
        
        # Montage the final_montage_montages:
        final_stack = create_stack_from_montage(final_montage_montages)
        final_montage = create_single_montage(len(final_montage_montages), 1, settings["label_font_size"], 1.0, settings["border_size"], final_stack)
        IJ.saveAs(final_montage, "Tiff", output_filepath)
        for imp in final_montage_montages:
            imp.close()
        final_stack.close()
        final_montage.close()

    else:

        for compound in final_filedict:
            if compound != "Controls":
                for gr_addition in final_filedict[compound]:
                    for concentration in final_filedict[compound][gr_addition]:
                        for image_fp in final_filedict[compound][gr_addition][concentration]:
                            label_name = extract_well_id(os.path.basename(image_fp)) + "_" + compound + "_" + gr_addition + "_" + concentration
                            # images_to_montage = final_filedict[compound][gr_addition][concentration][0]
                            final_montage_montages.append((image_fp, label_name))
        #final_montage_montages is full of stacks or montages - should be considered images
        final_stack = create_stack(final_montage_montages)
        final_montage = create_single_montage(len(final_montage_montages), 1, settings["label_font_size"], settings["scale"], settings["border_size"], final_stack)
        IJ.saveAs(final_montage, "Tiff", output_filepath)
        final_stack.close()
        final_montage.close()

    print("Saved montage to {}".format(output_filepath))
    return "Success!"
    
settings = get_montage_settings()
print("Captured Montage Settings")
if settings is None:
    print("Captured no settings")
print(settings)

errors = errorlist()

for directory_tuple in settings["input_directory_list"]:

    directory, read_step = directory_tuple
    print("\nProcessing Montage from directory: {}".format(directory))

    # Filter out the wellIDs according to concentration/compound & PolyGR +/-
    isolated_wellIDs = isolate_wellIDs(settings, wellid_config)

    # Further filter out the wellIDs based on quadrant selection
    isolated_quadrants = isolate_quadrants(settings, isolated_wellIDs)

    # Get a list of the eligible tif files after filtering for the channel and read step
    eligible_tifs = filter_eligible_tifs(settings, directory, read_step)
    #print("\tSuccessfully found {} eligible tifs for montage from {} ".format(len(eligible_tifs), directory))
    if "ERROR" in eligible_tifs or eligible_tifs is None or len(eligible_tifs) < 1:
        #errors.log(directory, "filter_eligible_tifs returned None")
        errors.log(directory, eligible_tifs)
        continue

    # Filter and match the control wellIDs since they will be included in all montage images without exception
    control_filedict = filter_and_match_control_wellids(settings, wellid_config, eligible_tifs)
    if control_filedict is None:
        errors.log(directory, "filter_and_match_controls returned None for directory")
        continue
    #print("\tSuccessfully filtered and matched control group .tifs for {}".format(directory))
    # Validate that all the filepaths in the controls image list are real and skip if not real fps
    control_filedict_validity_conf = validate_files_to_montage(control_filedict)
    if control_filedict_validity_conf:
        print("control_filedict is valid for all filepaths!")
    elif not control_filedict_validity_conf:
        errors.log(directory, "validate_files_to_montage failed for controls: " + str(control_filedict))
        print("This may be because the wellIDs identified from your montage settings could not be found in the directory. Skipping this directory...")
        continue
    
    # Replace the wellIDs in the tifs to the corresponding tif filepaths
    quadrant_filedict = match_tifs_to_wellIDs(eligible_tifs, isolated_quadrants)

    # Validate that all the filepaths in the selected image list are real and skip if not real fps
    quadrant_filedict_validity_conf = validate_files_to_montage(quadrant_filedict)
    if quadrant_filedict_validity_conf:
        print("quadrant_filedict is valid for all filepaths!")
    elif not quadrant_filedict_validity_conf:
        errors.log(directory, "validate_files_to_montage failed for quadrant_filedict")
        print("This may be because the wellIDs identified from your montage settings could not be found in the directory. Skipping this directory...")
        continue
    
    #print("\nDirectory: {}\n\tquadrant_filedict: {}\n\tquadrant_filedict_validity_conf: {}\n\tcontrol_filedict: {}".format(directory, quadrant_filedict, quadrant_filedict_validity_conf, control_filedict))
    # Combine ye olde dictionaries together before sending them to create the montage
    combined_dict = quadrant_filedict.copy()
    combined_dict.update(control_filedict)

    montage_creation_confirmation = create_final_montage(settings, directory, combined_dict)
    print(montage_creation_confirmation)

# Print out all the errors from the logger
error_list = errors.get_all_errors()
print("\n\n{} ERRORS ENCOUNTERED".format(len(error_list)))
for index, element in enumerate(error_list):
    directory, reason = element
    print("{}. {}\n\t{}".format(index + 1, directory, reason))
